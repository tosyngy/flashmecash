{"ast":null,"code":"'use strict'; //This file contains then/promise specific extensions that are only useful for node.js interop\n\nvar Promise = require('./core.js');\n\nvar asap = require('asap');\n\nmodule.exports = Promise;\n/* Static Functions */\n\nPromise.denodeify = function (fn, argumentCount) {\n  argumentCount = argumentCount || Infinity;\n  return function () {\n    var self = this;\n    var args = Array.prototype.slice.call(arguments);\n    return new Promise(function (resolve, reject) {\n      while (args.length && args.length > argumentCount) {\n        args.pop();\n      }\n\n      args.push(function (err, res) {\n        if (err) reject(err);else resolve(res);\n      });\n      var res = fn.apply(self, args);\n\n      if (res && (typeof res === 'object' || typeof res === 'function') && typeof res.then === 'function') {\n        resolve(res);\n      }\n    });\n  };\n};\n\nPromise.nodeify = function (fn) {\n  return function () {\n    var args = Array.prototype.slice.call(arguments);\n    var callback = typeof args[args.length - 1] === 'function' ? args.pop() : null;\n    var ctx = this;\n\n    try {\n      return fn.apply(this, arguments).nodeify(callback, ctx);\n    } catch (ex) {\n      if (callback === null || typeof callback == 'undefined') {\n        return new Promise(function (resolve, reject) {\n          reject(ex);\n        });\n      } else {\n        asap(function () {\n          callback.call(ctx, ex);\n        });\n      }\n    }\n  };\n};\n\nPromise.prototype.nodeify = function (callback, ctx) {\n  if (typeof callback != 'function') return this;\n  this.then(function (value) {\n    asap(function () {\n      callback.call(ctx, null, value);\n    });\n  }, function (err) {\n    asap(function () {\n      callback.call(ctx, err);\n    });\n  });\n};","map":null,"metadata":{},"sourceType":"script"}