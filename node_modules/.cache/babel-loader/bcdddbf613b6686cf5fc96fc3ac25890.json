{"ast":null,"code":"/*\r\n    HTTP Hawk Authentication Scheme\r\n    Copyright (c) 2012-2014, Eran Hammer <eran@hammer.io>\r\n    BSD Licensed\r\n*/\n// Declare namespace\nvar hawk = {\n  internals: {}\n};\nhawk.client = {\n  // Generate an Authorization header for a given request\n\n  /*\r\n      uri: 'http://example.com/resource?a=b' or object generated by hawk.utils.parseUri()\r\n      method: HTTP verb (e.g. 'GET', 'POST')\r\n      options: {\r\n            // Required\r\n            credentials: {\r\n              id: 'dh37fgj492je',\r\n              key: 'aoijedoaijsdlaksjdl',\r\n              algorithm: 'sha256'                                 // 'sha1', 'sha256'\r\n          },\r\n            // Optional\r\n            ext: 'application-specific',                        // Application specific data sent via the ext attribute\r\n          timestamp: Date.now() / 1000,                       // A pre-calculated timestamp in seconds\r\n          nonce: '2334f34f',                                  // A pre-generated nonce\r\n          localtimeOffsetMsec: 400,                           // Time offset to sync with server time (ignored if timestamp provided)\r\n          payload: '{\"some\":\"payload\"}',                      // UTF-8 encoded string for body hash generation (ignored if hash provided)\r\n          contentType: 'application/json',                    // Payload content-type (ignored if hash provided)\r\n          hash: 'U4MKKSmiVxk37JCCrAVIjV=',                    // Pre-calculated payload hash\r\n          app: '24s23423f34dx',                               // Oz application id\r\n          dlg: '234sz34tww3sd'                                // Oz delegated-by application id\r\n      }\r\n  */\n  header: function header(uri, method, options) {\n    var result = {\n      field: '',\n      artifacts: {}\n    }; // Validate inputs\n\n    if (!uri || typeof uri !== 'string' && typeof uri !== 'object' || !method || typeof method !== 'string' || !options || typeof options !== 'object') {\n      result.err = 'Invalid argument type';\n      return result;\n    } // Application time\n\n\n    var timestamp = options.timestamp || hawk.utils.now(options.localtimeOffsetMsec); // Validate credentials\n\n    var credentials = options.credentials;\n\n    if (!credentials || !credentials.id || !credentials.key || !credentials.algorithm) {\n      result.err = 'Invalid credentials object';\n      return result;\n    }\n\n    if (hawk.crypto.algorithms.indexOf(credentials.algorithm) === -1) {\n      result.err = 'Unknown algorithm';\n      return result;\n    } // Parse URI\n\n\n    if (typeof uri === 'string') {\n      uri = hawk.utils.parseUri(uri);\n    } // Calculate signature\n\n\n    var artifacts = {\n      ts: timestamp,\n      nonce: options.nonce || hawk.utils.randomString(6),\n      method: method,\n      resource: uri.resource,\n      host: uri.host,\n      port: uri.port,\n      hash: options.hash,\n      ext: options.ext,\n      app: options.app,\n      dlg: options.dlg\n    };\n    result.artifacts = artifacts; // Calculate payload hash\n\n    if (!artifacts.hash && (options.payload || options.payload === '')) {\n      artifacts.hash = hawk.crypto.calculatePayloadHash(options.payload, credentials.algorithm, options.contentType);\n    }\n\n    var mac = hawk.crypto.calculateMac('header', credentials, artifacts); // Construct header\n\n    var hasExt = artifacts.ext !== null && artifacts.ext !== undefined && artifacts.ext !== ''; // Other falsey values allowed\n\n    var header = 'Hawk id=\"' + credentials.id + '\", ts=\"' + artifacts.ts + '\", nonce=\"' + artifacts.nonce + (artifacts.hash ? '\", hash=\"' + artifacts.hash : '') + (hasExt ? '\", ext=\"' + hawk.utils.escapeHeaderAttribute(artifacts.ext) : '') + '\", mac=\"' + mac + '\"';\n\n    if (artifacts.app) {\n      header += ', app=\"' + artifacts.app + (artifacts.dlg ? '\", dlg=\"' + artifacts.dlg : '') + '\"';\n    }\n\n    result.field = header;\n    return result;\n  },\n  // Generate a bewit value for a given URI\n\n  /*\r\n      uri: 'http://example.com/resource?a=b'\r\n      options: {\r\n            // Required\r\n            credentials: {\r\n          id: 'dh37fgj492je',\r\n          key: 'aoijedoaijsdlaksjdl',\r\n          algorithm: 'sha256'                             // 'sha1', 'sha256'\r\n          },\r\n          ttlSec: 60 * 60,                                    // TTL in seconds\r\n            // Optional\r\n            ext: 'application-specific',                        // Application specific data sent via the ext attribute\r\n          localtimeOffsetMsec: 400                            // Time offset to sync with server time\r\n       };\r\n  */\n  bewit: function bewit(uri, options) {\n    // Validate inputs\n    if (!uri || typeof uri !== 'string' || !options || typeof options !== 'object' || !options.ttlSec) {\n      return '';\n    }\n\n    options.ext = options.ext === null || options.ext === undefined ? '' : options.ext; // Zero is valid value\n    // Application time\n\n    var now = hawk.utils.now(options.localtimeOffsetMsec); // Validate credentials\n\n    var credentials = options.credentials;\n\n    if (!credentials || !credentials.id || !credentials.key || !credentials.algorithm) {\n      return '';\n    }\n\n    if (hawk.crypto.algorithms.indexOf(credentials.algorithm) === -1) {\n      return '';\n    } // Parse URI\n\n\n    uri = hawk.utils.parseUri(uri); // Calculate signature\n\n    var exp = now + options.ttlSec;\n    var mac = hawk.crypto.calculateMac('bewit', credentials, {\n      ts: exp,\n      nonce: '',\n      method: 'GET',\n      resource: uri.resource,\n      // Maintain trailing '?' and query params\n      host: uri.host,\n      port: uri.port,\n      ext: options.ext\n    }); // Construct bewit: id\\exp\\mac\\ext\n\n    var bewit = credentials.id + '\\\\' + exp + '\\\\' + mac + '\\\\' + options.ext;\n    return hawk.utils.base64urlEncode(bewit);\n  },\n  // Validate server response\n\n  /*\r\n      request:    object created via 'new XMLHttpRequest()' after response received\r\n      artifacts:  object received from header().artifacts\r\n      options: {\r\n          payload:    optional payload received\r\n          required:   specifies if a Server-Authorization header is required. Defaults to 'false'\r\n      }\r\n  */\n  authenticate: function authenticate(request, credentials, artifacts, options) {\n    options = options || {};\n\n    var getHeader = function getHeader(name) {\n      return request.getResponseHeader ? request.getResponseHeader(name) : request.getHeader(name);\n    };\n\n    var wwwAuthenticate = getHeader('www-authenticate');\n\n    if (wwwAuthenticate) {\n      // Parse HTTP WWW-Authenticate header\n      var wwwAttributes = hawk.utils.parseAuthorizationHeader(wwwAuthenticate, ['ts', 'tsm', 'error']);\n\n      if (!wwwAttributes) {\n        return false;\n      }\n\n      if (wwwAttributes.ts) {\n        var tsm = hawk.crypto.calculateTsMac(wwwAttributes.ts, credentials);\n\n        if (tsm !== wwwAttributes.tsm) {\n          return false;\n        }\n\n        hawk.utils.setNtpOffset(wwwAttributes.ts - Math.floor(new Date().getTime() / 1000)); // Keep offset at 1 second precision\n      }\n    } // Parse HTTP Server-Authorization header\n\n\n    var serverAuthorization = getHeader('server-authorization');\n\n    if (!serverAuthorization && !options.required) {\n      return true;\n    }\n\n    var attributes = hawk.utils.parseAuthorizationHeader(serverAuthorization, ['mac', 'ext', 'hash']);\n\n    if (!attributes) {\n      return false;\n    }\n\n    var modArtifacts = {\n      ts: artifacts.ts,\n      nonce: artifacts.nonce,\n      method: artifacts.method,\n      resource: artifacts.resource,\n      host: artifacts.host,\n      port: artifacts.port,\n      hash: attributes.hash,\n      ext: attributes.ext,\n      app: artifacts.app,\n      dlg: artifacts.dlg\n    };\n    var mac = hawk.crypto.calculateMac('response', credentials, modArtifacts);\n\n    if (mac !== attributes.mac) {\n      return false;\n    }\n\n    if (!options.payload && options.payload !== '') {\n      return true;\n    }\n\n    if (!attributes.hash) {\n      return false;\n    }\n\n    var calculatedHash = hawk.crypto.calculatePayloadHash(options.payload, credentials.algorithm, getHeader('content-type'));\n    return calculatedHash === attributes.hash;\n  },\n  message: function message(host, port, _message, options) {\n    // Validate inputs\n    if (!host || typeof host !== 'string' || !port || typeof port !== 'number' || _message === null || _message === undefined || typeof _message !== 'string' || !options || typeof options !== 'object') {\n      return null;\n    } // Application time\n\n\n    var timestamp = options.timestamp || hawk.utils.now(options.localtimeOffsetMsec); // Validate credentials\n\n    var credentials = options.credentials;\n\n    if (!credentials || !credentials.id || !credentials.key || !credentials.algorithm) {\n      // Invalid credential object\n      return null;\n    }\n\n    if (hawk.crypto.algorithms.indexOf(credentials.algorithm) === -1) {\n      return null;\n    } // Calculate signature\n\n\n    var artifacts = {\n      ts: timestamp,\n      nonce: options.nonce || hawk.utils.randomString(6),\n      host: host,\n      port: port,\n      hash: hawk.crypto.calculatePayloadHash(_message, credentials.algorithm)\n    }; // Construct authorization\n\n    var result = {\n      id: credentials.id,\n      ts: artifacts.ts,\n      nonce: artifacts.nonce,\n      hash: artifacts.hash,\n      mac: hawk.crypto.calculateMac('message', credentials, artifacts)\n    };\n    return result;\n  },\n  authenticateTimestamp: function authenticateTimestamp(message, credentials, updateClock) {\n    // updateClock defaults to true\n    var tsm = hawk.crypto.calculateTsMac(message.ts, credentials);\n\n    if (tsm !== message.tsm) {\n      return false;\n    }\n\n    if (updateClock !== false) {\n      hawk.utils.setNtpOffset(message.ts - Math.floor(new Date().getTime() / 1000)); // Keep offset at 1 second precision\n    }\n\n    return true;\n  }\n};\nhawk.crypto = {\n  headerVersion: '1',\n  algorithms: ['sha1', 'sha256'],\n  calculateMac: function calculateMac(type, credentials, options) {\n    var normalized = hawk.crypto.generateNormalizedString(type, options);\n    var hmac = CryptoJS['Hmac' + credentials.algorithm.toUpperCase()](normalized, credentials.key);\n    return hmac.toString(CryptoJS.enc.Base64);\n  },\n  generateNormalizedString: function generateNormalizedString(type, options) {\n    var normalized = 'hawk.' + hawk.crypto.headerVersion + '.' + type + '\\n' + options.ts + '\\n' + options.nonce + '\\n' + (options.method || '').toUpperCase() + '\\n' + (options.resource || '') + '\\n' + options.host.toLowerCase() + '\\n' + options.port + '\\n' + (options.hash || '') + '\\n';\n\n    if (options.ext) {\n      normalized += options.ext.replace('\\\\', '\\\\\\\\').replace('\\n', '\\\\n');\n    }\n\n    normalized += '\\n';\n\n    if (options.app) {\n      normalized += options.app + '\\n' + (options.dlg || '') + '\\n';\n    }\n\n    return normalized;\n  },\n  calculatePayloadHash: function calculatePayloadHash(payload, algorithm, contentType) {\n    var hash = CryptoJS.algo[algorithm.toUpperCase()].create();\n    hash.update('hawk.' + hawk.crypto.headerVersion + '.payload\\n');\n    hash.update(hawk.utils.parseContentType(contentType) + '\\n');\n    hash.update(payload);\n    hash.update('\\n');\n    return hash.finalize().toString(CryptoJS.enc.Base64);\n  },\n  calculateTsMac: function calculateTsMac(ts, credentials) {\n    var hash = CryptoJS['Hmac' + credentials.algorithm.toUpperCase()]('hawk.' + hawk.crypto.headerVersion + '.ts\\n' + ts + '\\n', credentials.key);\n    return hash.toString(CryptoJS.enc.Base64);\n  }\n}; // localStorage compatible interface\n\nhawk.internals.LocalStorage = function () {\n  this._cache = {};\n  this.length = 0;\n\n  this.getItem = function (key) {\n    return this._cache.hasOwnProperty(key) ? String(this._cache[key]) : null;\n  };\n\n  this.setItem = function (key, value) {\n    this._cache[key] = String(value);\n    this.length = Object.keys(this._cache).length;\n  };\n\n  this.removeItem = function (key) {\n    delete this._cache[key];\n    this.length = Object.keys(this._cache).length;\n  };\n\n  this.clear = function () {\n    this._cache = {};\n    this.length = 0;\n  };\n\n  this.key = function (i) {\n    return Object.keys(this._cache)[i || 0];\n  };\n};\n\nhawk.utils = {\n  storage: new hawk.internals.LocalStorage(),\n  setStorage: function setStorage(storage) {\n    var ntpOffset = hawk.utils.storage.getItem('hawk_ntp_offset');\n    hawk.utils.storage = storage;\n\n    if (ntpOffset) {\n      hawk.utils.setNtpOffset(ntpOffset);\n    }\n  },\n  setNtpOffset: function setNtpOffset(offset) {\n    try {\n      hawk.utils.storage.setItem('hawk_ntp_offset', offset);\n    } catch (err) {\n      console.error('[hawk] could not write to storage.');\n      console.error(err);\n    }\n  },\n  getNtpOffset: function getNtpOffset() {\n    var offset = hawk.utils.storage.getItem('hawk_ntp_offset');\n\n    if (!offset) {\n      return 0;\n    }\n\n    return parseInt(offset, 10);\n  },\n  now: function now(localtimeOffsetMsec) {\n    return Math.floor((new Date().getTime() + (localtimeOffsetMsec || 0)) / 1000) + hawk.utils.getNtpOffset();\n  },\n  escapeHeaderAttribute: function escapeHeaderAttribute(attribute) {\n    return attribute.replace(/\\\\/g, '\\\\\\\\').replace(/\\\"/g, '\\\\\"');\n  },\n  parseContentType: function parseContentType(header) {\n    if (!header) {\n      return '';\n    }\n\n    return header.split(';')[0].replace(/^\\s+|\\s+$/g, '').toLowerCase();\n  },\n  parseAuthorizationHeader: function parseAuthorizationHeader(header, keys) {\n    if (!header) {\n      return null;\n    }\n\n    var headerParts = header.match(/^(\\w+)(?:\\s+(.*))?$/); // Header: scheme[ something]\n\n    if (!headerParts) {\n      return null;\n    }\n\n    var scheme = headerParts[1];\n\n    if (scheme.toLowerCase() !== 'hawk') {\n      return null;\n    }\n\n    var attributesString = headerParts[2];\n\n    if (!attributesString) {\n      return null;\n    }\n\n    var attributes = {};\n    var verify = attributesString.replace(/(\\w+)=\"([^\"\\\\]*)\"\\s*(?:,\\s*|$)/g, function ($0, $1, $2) {\n      // Check valid attribute names\n      if (keys.indexOf($1) === -1) {\n        return;\n      } // Allowed attribute value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9\n\n\n      if ($2.match(/^[ \\w\\!#\\$%&'\\(\\)\\*\\+,\\-\\.\\/\\:;<\\=>\\?@\\[\\]\\^`\\{\\|\\}~]+$/) === null) {\n        return;\n      } // Check for duplicates\n\n\n      if (attributes.hasOwnProperty($1)) {\n        return;\n      }\n\n      attributes[$1] = $2;\n      return '';\n    });\n\n    if (verify !== '') {\n      return null;\n    }\n\n    return attributes;\n  },\n  randomString: function randomString(size) {\n    var randomSource = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n    var len = randomSource.length;\n    var result = [];\n\n    for (var i = 0; i < size; ++i) {\n      result[i] = randomSource[Math.floor(Math.random() * len)];\n    }\n\n    return result.join('');\n  },\n  uriRegex: /^([^:]+)\\:\\/\\/(?:[^@]*@)?([^\\/:]+)(?:\\:(\\d+))?([^#]*)(?:#.*)?$/,\n  // scheme://credentials@host:port/resource#fragment\n  parseUri: function parseUri(input) {\n    var parts = input.match(hawk.utils.uriRegex);\n\n    if (!parts) {\n      return {\n        host: '',\n        port: '',\n        resource: ''\n      };\n    }\n\n    var scheme = parts[1].toLowerCase();\n    var uri = {\n      host: parts[2],\n      port: parts[3] || (scheme === 'http' ? '80' : scheme === 'https' ? '443' : ''),\n      resource: parts[4]\n    };\n    return uri;\n  },\n  base64urlEncode: function base64urlEncode(value) {\n    var wordArray = CryptoJS.enc.Utf8.parse(value);\n    var encoded = CryptoJS.enc.Base64.stringify(wordArray);\n    return encoded.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/\\=/g, '');\n  }\n}; // $lab:coverage:off$\n\n/* eslint-disable */\n// Based on: Crypto-JS v3.1.2\n// Copyright (c) 2009-2013, Jeff Mott. All rights reserved.\n// http://code.google.com/p/crypto-js/\n// http://code.google.com/p/crypto-js/wiki/License\n\nvar CryptoJS = CryptoJS || function (h, r) {\n  var k = {},\n      l = k.lib = {},\n      n = function n() {},\n      f = l.Base = {\n    extend: function extend(a) {\n      n.prototype = this;\n      var b = new n();\n      a && b.mixIn(a);\n      b.hasOwnProperty(\"init\") || (b.init = function () {\n        b.$super.init.apply(this, arguments);\n      });\n      b.init.prototype = b;\n      b.$super = this;\n      return b;\n    },\n    create: function create() {\n      var a = this.extend();\n      a.init.apply(a, arguments);\n      return a;\n    },\n    init: function init() {},\n    mixIn: function mixIn(a) {\n      for (var b in a) {\n        a.hasOwnProperty(b) && (this[b] = a[b]);\n      }\n\n      a.hasOwnProperty(\"toString\") && (this.toString = a.toString);\n    },\n    clone: function clone() {\n      return this.init.prototype.extend(this);\n    }\n  },\n      j = l.WordArray = f.extend({\n    init: function init(a, b) {\n      a = this.words = a || [];\n      this.sigBytes = b != r ? b : 4 * a.length;\n    },\n    toString: function toString(a) {\n      return (a || s).stringify(this);\n    },\n    concat: function concat(a) {\n      var b = this.words,\n          d = a.words,\n          c = this.sigBytes;\n      a = a.sigBytes;\n      this.clamp();\n      if (c % 4) for (var e = 0; e < a; e++) {\n        b[c + e >>> 2] |= (d[e >>> 2] >>> 24 - 8 * (e % 4) & 255) << 24 - 8 * ((c + e) % 4);\n      } else if (65535 < d.length) for (e = 0; e < a; e += 4) {\n        b[c + e >>> 2] = d[e >>> 2];\n      } else b.push.apply(b, d);\n      this.sigBytes += a;\n      return this;\n    },\n    clamp: function clamp() {\n      var a = this.words,\n          b = this.sigBytes;\n      a[b >>> 2] &= 4294967295 << 32 - 8 * (b % 4);\n      a.length = h.ceil(b / 4);\n    },\n    clone: function clone() {\n      var a = f.clone.call(this);\n      a.words = this.words.slice(0);\n      return a;\n    },\n    random: function random(a) {\n      for (var b = [], d = 0; d < a; d += 4) {\n        b.push(4294967296 * h.random() | 0);\n      }\n\n      return new j.init(b, a);\n    }\n  }),\n      m = k.enc = {},\n      s = m.Hex = {\n    stringify: function stringify(a) {\n      var b = a.words;\n      a = a.sigBytes;\n\n      for (var d = [], c = 0; c < a; c++) {\n        var e = b[c >>> 2] >>> 24 - 8 * (c % 4) & 255;\n        d.push((e >>> 4).toString(16));\n        d.push((e & 15).toString(16));\n      }\n\n      return d.join(\"\");\n    },\n    parse: function parse(a) {\n      for (var b = a.length, d = [], c = 0; c < b; c += 2) {\n        d[c >>> 3] |= parseInt(a.substr(c, 2), 16) << 24 - 4 * (c % 8);\n      }\n\n      return new j.init(d, b / 2);\n    }\n  },\n      p = m.Latin1 = {\n    stringify: function stringify(a) {\n      var b = a.words;\n      a = a.sigBytes;\n\n      for (var d = [], c = 0; c < a; c++) {\n        d.push(String.fromCharCode(b[c >>> 2] >>> 24 - 8 * (c % 4) & 255));\n      }\n\n      return d.join(\"\");\n    },\n    parse: function parse(a) {\n      for (var b = a.length, d = [], c = 0; c < b; c++) {\n        d[c >>> 2] |= (a.charCodeAt(c) & 255) << 24 - 8 * (c % 4);\n      }\n\n      return new j.init(d, b);\n    }\n  },\n      t = m.Utf8 = {\n    stringify: function stringify(a) {\n      try {\n        return decodeURIComponent(escape(p.stringify(a)));\n      } catch (b) {\n        throw Error(\"Malformed UTF-8 data\");\n      }\n    },\n    parse: function parse(a) {\n      return p.parse(unescape(encodeURIComponent(a)));\n    }\n  },\n      q = l.BufferedBlockAlgorithm = f.extend({\n    reset: function reset() {\n      this._data = new j.init();\n      this._nDataBytes = 0;\n    },\n    _append: function _append(a) {\n      \"string\" == typeof a && (a = t.parse(a));\n\n      this._data.concat(a);\n\n      this._nDataBytes += a.sigBytes;\n    },\n    _process: function _process(a) {\n      var b = this._data,\n          d = b.words,\n          c = b.sigBytes,\n          e = this.blockSize,\n          f = c / (4 * e),\n          f = a ? h.ceil(f) : h.max((f | 0) - this._minBufferSize, 0);\n      a = f * e;\n      c = h.min(4 * a, c);\n\n      if (a) {\n        for (var g = 0; g < a; g += e) {\n          this._doProcessBlock(d, g);\n        }\n\n        g = d.splice(0, a);\n        b.sigBytes -= c;\n      }\n\n      return new j.init(g, c);\n    },\n    clone: function clone() {\n      var a = f.clone.call(this);\n      a._data = this._data.clone();\n      return a;\n    },\n    _minBufferSize: 0\n  });\n\n  l.Hasher = q.extend({\n    cfg: f.extend(),\n    init: function init(a) {\n      this.cfg = this.cfg.extend(a);\n      this.reset();\n    },\n    reset: function reset() {\n      q.reset.call(this);\n\n      this._doReset();\n    },\n    update: function update(a) {\n      this._append(a);\n\n      this._process();\n\n      return this;\n    },\n    finalize: function finalize(a) {\n      a && this._append(a);\n      return this._doFinalize();\n    },\n    blockSize: 16,\n    _createHelper: function _createHelper(a) {\n      return function (b, d) {\n        return new a.init(d).finalize(b);\n      };\n    },\n    _createHmacHelper: function _createHmacHelper(a) {\n      return function (b, d) {\n        return new u.HMAC.init(a, d).finalize(b);\n      };\n    }\n  });\n  var u = k.algo = {};\n  return k;\n}(Math);\n\n(function () {\n  var k = CryptoJS,\n      b = k.lib,\n      m = b.WordArray,\n      l = b.Hasher,\n      d = [],\n      b = k.algo.SHA1 = l.extend({\n    _doReset: function _doReset() {\n      this._hash = new m.init([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);\n    },\n    _doProcessBlock: function _doProcessBlock(n, p) {\n      for (var a = this._hash.words, e = a[0], f = a[1], h = a[2], j = a[3], b = a[4], c = 0; 80 > c; c++) {\n        if (16 > c) d[c] = n[p + c] | 0;else {\n          var g = d[c - 3] ^ d[c - 8] ^ d[c - 14] ^ d[c - 16];\n          d[c] = g << 1 | g >>> 31;\n        }\n        g = (e << 5 | e >>> 27) + b + d[c];\n        g = 20 > c ? g + ((f & h | ~f & j) + 1518500249) : 40 > c ? g + ((f ^ h ^ j) + 1859775393) : 60 > c ? g + ((f & h | f & j | h & j) - 1894007588) : g + ((f ^ h ^ j) - 899497514);\n        b = j;\n        j = h;\n        h = f << 30 | f >>> 2;\n        f = e;\n        e = g;\n      }\n\n      a[0] = a[0] + e | 0;\n      a[1] = a[1] + f | 0;\n      a[2] = a[2] + h | 0;\n      a[3] = a[3] + j | 0;\n      a[4] = a[4] + b | 0;\n    },\n    _doFinalize: function _doFinalize() {\n      var b = this._data,\n          d = b.words,\n          a = 8 * this._nDataBytes,\n          e = 8 * b.sigBytes;\n      d[e >>> 5] |= 128 << 24 - e % 32;\n      d[(e + 64 >>> 9 << 4) + 14] = Math.floor(a / 4294967296);\n      d[(e + 64 >>> 9 << 4) + 15] = a;\n      b.sigBytes = 4 * d.length;\n\n      this._process();\n\n      return this._hash;\n    },\n    clone: function clone() {\n      var b = l.clone.call(this);\n      b._hash = this._hash.clone();\n      return b;\n    }\n  });\n  k.SHA1 = l._createHelper(b);\n  k.HmacSHA1 = l._createHmacHelper(b);\n})();\n\n(function (k) {\n  for (var g = CryptoJS, h = g.lib, v = h.WordArray, j = h.Hasher, h = g.algo, s = [], t = [], u = function u(q) {\n    return 4294967296 * (q - (q | 0)) | 0;\n  }, l = 2, b = 0; 64 > b;) {\n    var d;\n\n    a: {\n      d = l;\n\n      for (var w = k.sqrt(d), r = 2; r <= w; r++) {\n        if (!(d % r)) {\n          d = !1;\n          break a;\n        }\n      }\n\n      d = !0;\n    }\n\n    d && (8 > b && (s[b] = u(k.pow(l, 0.5))), t[b] = u(k.pow(l, 1 / 3)), b++);\n    l++;\n  }\n\n  var n = [],\n      h = h.SHA256 = j.extend({\n    _doReset: function _doReset() {\n      this._hash = new v.init(s.slice(0));\n    },\n    _doProcessBlock: function _doProcessBlock(q, h) {\n      for (var a = this._hash.words, c = a[0], d = a[1], b = a[2], k = a[3], f = a[4], g = a[5], j = a[6], l = a[7], e = 0; 64 > e; e++) {\n        if (16 > e) n[e] = q[h + e] | 0;else {\n          var m = n[e - 15],\n              p = n[e - 2];\n          n[e] = ((m << 25 | m >>> 7) ^ (m << 14 | m >>> 18) ^ m >>> 3) + n[e - 7] + ((p << 15 | p >>> 17) ^ (p << 13 | p >>> 19) ^ p >>> 10) + n[e - 16];\n        }\n        m = l + ((f << 26 | f >>> 6) ^ (f << 21 | f >>> 11) ^ (f << 7 | f >>> 25)) + (f & g ^ ~f & j) + t[e] + n[e];\n        p = ((c << 30 | c >>> 2) ^ (c << 19 | c >>> 13) ^ (c << 10 | c >>> 22)) + (c & d ^ c & b ^ d & b);\n        l = j;\n        j = g;\n        g = f;\n        f = k + m | 0;\n        k = b;\n        b = d;\n        d = c;\n        c = m + p | 0;\n      }\n\n      a[0] = a[0] + c | 0;\n      a[1] = a[1] + d | 0;\n      a[2] = a[2] + b | 0;\n      a[3] = a[3] + k | 0;\n      a[4] = a[4] + f | 0;\n      a[5] = a[5] + g | 0;\n      a[6] = a[6] + j | 0;\n      a[7] = a[7] + l | 0;\n    },\n    _doFinalize: function _doFinalize() {\n      var d = this._data,\n          b = d.words,\n          a = 8 * this._nDataBytes,\n          c = 8 * d.sigBytes;\n      b[c >>> 5] |= 128 << 24 - c % 32;\n      b[(c + 64 >>> 9 << 4) + 14] = k.floor(a / 4294967296);\n      b[(c + 64 >>> 9 << 4) + 15] = a;\n      d.sigBytes = 4 * b.length;\n\n      this._process();\n\n      return this._hash;\n    },\n    clone: function clone() {\n      var b = j.clone.call(this);\n      b._hash = this._hash.clone();\n      return b;\n    }\n  });\n  g.SHA256 = j._createHelper(h);\n  g.HmacSHA256 = j._createHmacHelper(h);\n})(Math);\n\n(function () {\n  var c = CryptoJS,\n      k = c.enc.Utf8;\n  c.algo.HMAC = c.lib.Base.extend({\n    init: function init(a, b) {\n      a = this._hasher = new a.init();\n      \"string\" == typeof b && (b = k.parse(b));\n      var c = a.blockSize,\n          e = 4 * c;\n      b.sigBytes > e && (b = a.finalize(b));\n      b.clamp();\n\n      for (var f = this._oKey = b.clone(), g = this._iKey = b.clone(), h = f.words, j = g.words, d = 0; d < c; d++) {\n        h[d] ^= 1549556828, j[d] ^= 909522486;\n      }\n\n      f.sigBytes = g.sigBytes = e;\n      this.reset();\n    },\n    reset: function reset() {\n      var a = this._hasher;\n      a.reset();\n      a.update(this._iKey);\n    },\n    update: function update(a) {\n      this._hasher.update(a);\n\n      return this;\n    },\n    finalize: function finalize(a) {\n      var b = this._hasher;\n      a = b.finalize(a);\n      b.reset();\n      return b.finalize(this._oKey.clone().concat(a));\n    }\n  });\n})();\n\n(function () {\n  var h = CryptoJS,\n      j = h.lib.WordArray;\n  h.enc.Base64 = {\n    stringify: function stringify(b) {\n      var e = b.words,\n          f = b.sigBytes,\n          c = this._map;\n      b.clamp();\n      b = [];\n\n      for (var a = 0; a < f; a += 3) {\n        for (var d = (e[a >>> 2] >>> 24 - 8 * (a % 4) & 255) << 16 | (e[a + 1 >>> 2] >>> 24 - 8 * ((a + 1) % 4) & 255) << 8 | e[a + 2 >>> 2] >>> 24 - 8 * ((a + 2) % 4) & 255, g = 0; 4 > g && a + 0.75 * g < f; g++) {\n          b.push(c.charAt(d >>> 6 * (3 - g) & 63));\n        }\n      }\n\n      if (e = c.charAt(64)) for (; b.length % 4;) {\n        b.push(e);\n      }\n      return b.join(\"\");\n    },\n    parse: function parse(b) {\n      var e = b.length,\n          f = this._map,\n          c = f.charAt(64);\n      c && (c = b.indexOf(c), -1 != c && (e = c));\n\n      for (var c = [], a = 0, d = 0; d < e; d++) {\n        if (d % 4) {\n          var g = f.indexOf(b.charAt(d - 1)) << 2 * (d % 4),\n              h = f.indexOf(b.charAt(d)) >>> 6 - 2 * (d % 4);\n          c[a >>> 2] |= (g | h) << 24 - 8 * (a % 4);\n          a++;\n        }\n      }\n\n      return j.create(c, a);\n    },\n    _map: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"\n  };\n})();\n\nhawk.crypto.internals = CryptoJS; // Export if used as a module\n\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = hawk;\n}\n/* eslint-enable */\n// $lab:coverage:on$","map":null,"metadata":{},"sourceType":"script"}