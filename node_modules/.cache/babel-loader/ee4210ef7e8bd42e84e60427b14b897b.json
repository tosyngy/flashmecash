{"ast":null,"code":"'use strict';\n\nvar asap = require('asap');\n\nmodule.exports = Promise;\n\nfunction Promise(fn) {\n  if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');\n  if (typeof fn !== 'function') throw new TypeError('not a function');\n  var state = null;\n  var value = null;\n  var deferreds = [];\n  var self = this;\n\n  this.then = function (onFulfilled, onRejected) {\n    return new self.constructor(function (resolve, reject) {\n      handle(new Handler(onFulfilled, onRejected, resolve, reject));\n    });\n  };\n\n  function handle(deferred) {\n    if (state === null) {\n      deferreds.push(deferred);\n      return;\n    }\n\n    asap(function () {\n      var cb = state ? deferred.onFulfilled : deferred.onRejected;\n\n      if (cb === null) {\n        (state ? deferred.resolve : deferred.reject)(value);\n        return;\n      }\n\n      var ret;\n\n      try {\n        ret = cb(value);\n      } catch (e) {\n        deferred.reject(e);\n        return;\n      }\n\n      deferred.resolve(ret);\n    });\n  }\n\n  function resolve(newValue) {\n    try {\n      //Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');\n\n      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {\n        var then = newValue.then;\n\n        if (typeof then === 'function') {\n          doResolve(then.bind(newValue), resolve, reject);\n          return;\n        }\n      }\n\n      state = true;\n      value = newValue;\n      finale();\n    } catch (e) {\n      reject(e);\n    }\n  }\n\n  function reject(newValue) {\n    state = false;\n    value = newValue;\n    finale();\n  }\n\n  function finale() {\n    for (var i = 0, len = deferreds.length; i < len; i++) {\n      handle(deferreds[i]);\n    }\n\n    deferreds = null;\n  }\n\n  doResolve(fn, resolve, reject);\n}\n\nfunction Handler(onFulfilled, onRejected, resolve, reject) {\n  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n  this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n  this.resolve = resolve;\n  this.reject = reject;\n}\n/**\n * Take a potentially misbehaving resolver function and make sure\n * onFulfilled and onRejected are only called once.\n *\n * Makes no guarantees about asynchrony.\n */\n\n\nfunction doResolve(fn, onFulfilled, onRejected) {\n  var done = false;\n\n  try {\n    fn(function (value) {\n      if (done) return;\n      done = true;\n      onFulfilled(value);\n    }, function (reason) {\n      if (done) return;\n      done = true;\n      onRejected(reason);\n    });\n  } catch (ex) {\n    if (done) return;\n    done = true;\n    onRejected(ex);\n  }\n}","map":null,"metadata":{},"sourceType":"script"}