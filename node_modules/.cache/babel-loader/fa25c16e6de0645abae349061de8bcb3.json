{"ast":null,"code":"'use strict';\n\nvar Promise = require('promise');\n\nvar handleQs = require('then-request/lib/handle-qs.js');\n\nvar jsonpID = 0;\nvar queues = {};\nmodule.exports = pquest;\n\nfunction pquest(method, url, options, callback) {\n  var result = new Promise(function (resolve, reject) {\n    // check types of arguments\n    if (typeof method !== 'string') {\n      throw new TypeError('The method must be a string.');\n    }\n\n    if (typeof url !== 'string') {\n      throw new TypeError('The URL/path must be a string.');\n    }\n\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    if (options === null || options === undefined) {\n      options = {};\n    }\n\n    if (typeof options !== 'object') {\n      throw new TypeError('Options must be an object (or null).');\n    }\n\n    if (typeof callback !== 'function') {\n      callback = undefined;\n    }\n\n    if (options.body) {\n      throw new TypeError('JSONP does not support requests that have bodies');\n    }\n\n    if (options.headers) {\n      throw new TypeError('JSONP does not support requests that specify headers');\n    }\n\n    if (options.followRedirects === false) {\n      throw new TypeError('JSONP does not support requests that do not follow redirects');\n    }\n\n    options.qs = options.qs || {};\n\n    if (options.json) {\n      Object.keys(options.json).forEach(function (key) {\n        options.qs[key] = options.json[key];\n      });\n      delete options.json;\n    }\n\n    var callbackName = options.callbackName || 'then_jsonp_' + ++jsonpID;\n\n    if (options.callbackParameter !== false) {\n      options.qs[options.callbackParameter || 'callback'] = callbackName;\n    }\n\n    if (method.toLowerCase() !== 'get') {\n      options.qs[options.methodParameter || 'method'] = method;\n    }\n\n    if (queues[callbackName]) {\n      queues[callbackName].push(run);\n    } else {\n      queues[callbackName] = [];\n      run();\n    }\n\n    function run() {\n      // handle query string\n      if (options.qs) {\n        url = handleQs(url, options.qs);\n      }\n\n      var script = document.createElement('script');\n      var head = document.getElementsByTagName('head')[0] || document.documentElement;\n      var abortTimeout;\n      var done = false;\n\n      function onComplete(success) {\n        if (!done) {\n          done = true;\n          script.onload = script.onreadystatechange = script.onerror = null;\n          clearTimeout(abortTimeout);\n\n          if (callbackName in window) {\n            if (success) delete window[callbackName];else window[callbackName] = function () {};\n          }\n\n          if (script && script.parentNode) {\n            script.parentNode.removeChild(script);\n          }\n\n          if (queues[callbackName].length) queues[callbackName].shift()();else delete queues[callbackName];\n        }\n      }\n\n      script.onload = script.onreadystatechange = function () {\n        if (!this.readyState || this.readyState === \"loaded\" || this.readyState === \"complete\") {\n          onComplete();\n          setTimeout(function () {\n            reject(new Error('JSONP callback should already have been called'));\n          }, 100);\n        }\n      };\n\n      script.onerror = function () {\n        onComplete();\n        reject(new Error('JSONP request failed'));\n      };\n\n      window[callbackName] = function (result) {\n        onComplete(true);\n        resolve(result);\n      };\n\n      abortTimeout = setTimeout(function () {\n        onComplete();\n        reject(new Error('JSONP timed out'));\n      }, options.timeout || 10000);\n      script.src = url;\n      script.async = true;\n      head.appendChild(script);\n    }\n  });\n\n  result.getBody = function () {\n    return result.then(function (res) {\n      return res.getBody();\n    });\n  };\n\n  return result.nodeify(callback);\n}","map":null,"metadata":{},"sourceType":"script"}